//
// Created by manuel on 06.11.16.
//

#include <assembly.hh>
#include <iostream>


|.arch x64

|.section code
|.globals lbl_
|.actionlist impala_actions

#include <sys/mman.h>

#if !defined(MAP_ANONYMOUS) && defined(MAP_ANON)
#define MAP_ANONYMOUS MAP_ANON
#endif

Assembly::~Assembly()
{
    dasm_free(&d);
}

void Assembly::initialize() {
    dasm_init(&d, DASM_MAXSECTION);

    void* labels[lbl__MAX];
    dasm_setupglobal(&d, labels, lbl__MAX);

    dasm_setup(&d, impala_actions);

    dasm_growpc(&d, 0);

    Dst = &d;
}

void Assembly::prologue(){

    | push rbp
    | mov rbp, rsp
    | mov rax, rbp
    | sub rax, 16

    std::cout << "| push rbp" << std::endl;
    std::cout << "| mov rbp, rsp" << std::endl;
    std::cout << "| mov rax, rbp" << std::endl;
    std::cout << "| sub rax, 16" << std::endl;
}

void Assembly::growPC(unsigned npc)
{
    dasm_growpc(&d, npc);
}

void Assembly::pushConstantToFPUStack(double *value){
    | fld qword [value]
    std::cout << "| fld " << *value << std::endl;
}

void Assembly::storeLocalVariable() {
    | fstp qword [rax]
    | sub rax, 8
    std::cout << "| fstp qword [rax]" << std::endl;
    std::cout << "| sub rax, 8" << std::endl;
}

void Assembly::pushParameterToFPUStack(int index) {
    switch(index){
        case 0:
            {
                | movlpd qword [rbp-8], xmm0
                | fld qword [rbp-8]
                break;
            }
        case 1:
            {
                | movlpd qword [rbp-8], xmm1
                | fld qword [rbp-8]
                break;
            }
        case 2:
            {
                | movlpd qword [rbp-8], xmm2
                | fld qword [rbp-8]
                break;
            }
        case 3:
            {
                | movlpd qword [rbp-8], xmm3
                | fld qword [rbp-8]
                break;
            }
        case 4:
            {
                | movlpd qword [rbp-8], xmm4
                | fld qword [rbp-8]
                break;
            }
        case 5:
            {
                | movlpd qword [rbp-8], xmm5
                | fld qword [rbp-8]
                break;
            }
        case 6:
            {
                | movlpd qword [rbp-8], xmm6
                | fld qword [rbp-8]
                break;
            }
        case 7:
            {
                | movlpd qword [rbp-8], xmm7
                | fld qword [rbp-8]
                break;
            }
        default:
            {
                | fld qword [rbp+(8+(index-7)*8)]
                break;
            }
    }
    std::cout << "| fld qword [rbp+" << (8+(index-7)*8) << "]" << std::endl;
}

void Assembly::replaceParameter(int index) {
    switch(index){
        case 0:
            {
                | fstp qword [rbp-8]
                | movlpd xmm0, qword [rbp-8]
                break;
            }
        case 1:
            {
                | fstp qword [rbp-8]
                | movlpd xmm1, qword [rbp-8]
                break;
            }
        case 2:
            {
                | fstp qword [rbp-8]
                | movlpd xmm2, qword [rbp-8]
                break;
            }
        case 3:
            {
                | fstp qword [rbp-8]
                | movlpd xmm3, qword [rbp-8]
                break;
            }
        case 4:
            {
                | fstp qword [rbp-8]
                | movlpd xmm4, qword [rbp-8]
                break;
            }
        case 5:
            {
                | fstp qword [rbp-8]
                | movlpd xmm5, qword [rbp-8]
                break;
            }
        case 6:
            {
                | fstp qword [rbp-8]
                | movlpd xmm6, qword [rbp-8]
                break;
            }
        case 7:
            {
                | fstp qword [rbp-8]
                | movlpd xmm7, qword [rbp-8]
                break;
            }
        default:
            {
                | fstp qword [rbp+(8+(index-7)*8)]
                break;
            }
    }
    std::cout << "| fstp qword [rbp+" << (8+(index-7)*8) << "]" << std::endl;
}

void Assembly::pushLocalVariableToFPUStack(int index) {
    | fld qword [rbp-(16+index*8)]
    std::cout << "| fld qword [rbp-" << (16+index*8) << "]" << std::endl;
}

void Assembly::replaceLocalVariable(int index) {
    | fstp qword [rbp-(16+index*8)]
    std::cout << "| fstp qword [rbp-" << (16+index*8) << "]" << std::endl;
}

void Assembly::addDynamicLabel(unsigned labelNumber) {
    | =>labelNumber:
    std::cout << "| =>" << labelNumber << ":" << std::endl;
}

void Assembly::jumpForwardToDynamicLabel(unsigned labelNumber) {
    | jmp =>labelNumber
    std::cout << "| jmp =>" << labelNumber << std::endl;
}


void Assembly::conditionalJumpForwardToDynamicLabel(unsigned labelNumber, bool condition, CompareOperatorType operator_){
    if(condition == false){
        switch(operator_){
            case EQ:
            {
                | jne  =>labelNumber
                std::cout << "| jne  =>" << labelNumber << std::endl;
                break;
            }
            case NE:
            {
                | je  =>labelNumber
                std::cout << "| je  =>" << labelNumber << std::endl;
                break;
            }
            case GT:
            {
                | jbe  =>labelNumber
                std::cout << "| jbe  =>" << labelNumber << std::endl;
                break;
            }
            case LT:
            {
                | jae  =>labelNumber
                std::cout << "| jae  =>" << labelNumber << std::endl;
                break;
            }
            case GTE:
            {
                | jb  =>labelNumber
                std::cout << "| jbe  =>" << labelNumber << std::endl;
                break;
            }
            case LTE:
            {
                | ja  =>labelNumber
                std::cout << "| ja  =>" << labelNumber << std::endl;
                break;
            }
        }
    }
    else{
        switch(operator_){
            case EQ:
            {
                | je  =>labelNumber
                std::cout << "| je  =>" << labelNumber << std::endl;
                break;
            }
            case NE:
            {
                | jne  =>labelNumber
                std::cout << "| jne  =>" << labelNumber << std::endl;
                break;
            }
            case GT:
            {
                | ja  =>labelNumber
                std::cout << "| ja  =>" << labelNumber << std::endl;
                break;
            }
            case LT:
            {
                | jb  =>labelNumber
                std::cout << "| jb  =>" << labelNumber << std::endl;
                break;
            }
            case GTE:
            {
                | jge  =>labelNumber
                std::cout << "| jge  =>" << labelNumber << std::endl;
                break;
            }
            case LTE:
            {
                | jbe  =>labelNumber
                std::cout << "| jbe  =>" << labelNumber << std::endl;
                break;
            }
        }
     }
}

void Assembly::performNegation(){
    | fchs
    std::cout << "| fchs" << std::endl;
}

void Assembly::calculateAddition(){
    | faddp st1
    std::cout << "| faddp st1" << std::endl;
}

void Assembly::calculateSubtraction(){
    | fsubp st1
    std::cout << "| fsubp st1" << std::endl;
}

void Assembly::calculateMultiplication(){
    | fmulp st1
    std::cout << "| fmulp st1" << std::endl;
}

void Assembly::calculateDivision(){
    | fdivp st1
    std::cout << "| fdivp st1" << std::endl;
}

void Assembly::calculatePower(){
    | fyl2x
    | fld st0
    | frndint
    | fsubr st1,st0
    | fxch st1
    | fchs
    | f2xm1
    | fld1
    | faddp st1,st0
    | fscale
    | fstp st1

    std::cout << "| fyl2x" << std::endl;
    std::cout << "| fld st0" << std::endl;
    std::cout << "| frndint" << std::endl;
    std::cout << "| fsubr st1,st0" << std::endl;
    std::cout << "| fxch st1" << std::endl;
    std::cout << "| fchs" << std::endl;
    std::cout << "| f2xm1" << std::endl;
    std::cout << "| fld1" << std::endl;
    std::cout << "| faddp st1,st0" << std::endl;
    std::cout << "| fscale" << std::endl;
    std::cout << "| fstp st1" << std::endl;
}

void Assembly::calculateSQRT(){
    | fsqrt
    std::cout << "| fsqrt" << std::endl;
}

void Assembly::performComparison(){
    | fcomip st1
    | fpop
    std::cout << "| fcomip st1" << std::endl;
    std::cout << "| fpop" << std::endl;
}

void Assembly::extractResult(){
     | fstp qword [rbp-8]
     | movlpd xmm0, qword [rbp-8]
     std::cout << "| fstp qword [rbp-8]" << std::endl;
     std::cout << "| movlpd xmm0, qword [rbp-8]" << std::endl;
}


void Assembly::epilogue(){
    | pop rbp
    | ret
    std::cout << "| pop rbp" << std::endl;
    std::cout << "| ret" << std::endl;
}

dasm_gen_func Assembly::linkAndEncode(){
  size_t sz;
  void* buf;
  dasm_link(Dst, &sz);
  buf = mmap(0, sz, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);
  dasm_encode(Dst, buf);
  mprotect(buf, sz, PROT_READ | PROT_EXEC);
  return (dasm_gen_func) buf;
}
