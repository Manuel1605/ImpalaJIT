/**
 * Copyright 2017 Manuel Fasching <manuel.fasching@tum.de>
 * Distributed under the MIT License
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is furnished
 * to do so, subject to the following conditions:
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
 * INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
 * PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
 * FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

#include <assembly__avx.hh>
#include <iostream>
#include <stdio.h>
#include <stdint.h>


|.arch x64

|.section code

|.globals lbl_
|.actionlist impala_actions

#include <sys/mman.h>

#if !defined(MAP_ANONYMOUS) && defined(MAP_ANON)
#define MAP_ANONYMOUS MAP_ANON
#endif

/**
 * @see assembly__avx.hh
 */
Assembly__AVX::~Assembly__AVX()
{
    dasm_free(&d);
}

/**
 * @see assembly.hh
 */
void Assembly__AVX::initialize(int parameterCount) {
    std::cout << "ImpalaJIT: AVX Support enabled" << std::endl;
    dasm_init(&d, DASM_MAXSECTION);

    void* labels[lbl__MAX];
    dasm_setupglobal(&d, labels, lbl__MAX);

    dasm_setup(&d, impala_actions);

    dasm_growpc(&d, 0);

    Dst = &d;

    stackPos = parameterCount >= 8 ? 7 : parameterCount-1;
}

/**
 * @see assembly.hh
 */
void Assembly__AVX::prologue(){
    std::cout << "Right Assembly" << std::endl;
    | push rbp
    | mov rbp, rsp
}

/**
 * @see assembly.hh
 */
void Assembly__AVX::growPC(unsigned npc)
{
    dasm_growpc(&d, npc);
}

/**
 * @see assembly.hh
 */
void Assembly__AVX::pushConstantToStack(double value){
    stackPos++;
    double* ptr = static_cast<double*>(malloc(sizeof(double)));
    *ptr = value;
    | vmovq xmm(stackPos), qword[ptr]
}

/**
 * @see assembly.hh
 */
void Assembly__AVX::storeLocalVariable() {
    | sub rsp, 8
    | vmovq qword [rsp], xmm(stackPos)
    stackPos--;
}

/**
 * @see assembly.hh
 */
void Assembly__AVX::pushParameterToStack(int index) {
    stackPos++;
    // See x64 calling conventions. Paramters 1-8 are passed in registers
    if(index <= 7){
        | vmovq xmm(stackPos), xmm(index)
    }
    else {
        | vmovq xmm(stackPos), qword [rbp+8+(index-7)*8]
    }
}

/**
 * @see assembly.hh
 */
void Assembly__AVX::replaceParameter(int index) {
    // See x64 calling conventions. Paramters 1-8 are passed in registers
    if(index <= 7){
        | vmovq xmm(index), xmm(stackPos)
    }
    else {
        | vmovq qword [rbp+8+(index-7)*8], xmm(stackPos)
    }
    stackPos--;
}

/**
 * @see assembly.hh
 */
void Assembly__AVX::pushLocalVariableToStack(int index) {
    stackPos++;
    | vmovq xmm(stackPos), qword [rbp-8-index*8]
}

/**
 * @see assembly.hh
 */
void Assembly__AVX::replaceLocalVariable(int index) {
    | vmovq qword [rbp-8-index*8], xmm(stackPos)
    stackPos--;
}

/**
 * @see assembly.hh
 */
void Assembly__AVX::addDynamicLabel(unsigned labelNumber) {
    | =>labelNumber:
}

/**
 * @see assembly.hh
 */
void Assembly__AVX::jumpForwardToDynamicLabel(unsigned labelNumber) {
    | jmp =>labelNumber
}

/**
 * @see assembly.hh
 */
void Assembly__AVX::conditionalJumpForwardToDynamicLabel(unsigned labelNumber, bool condition, CompareOperatorType operator_){
     | vcmpsd xmm(stackPos), xmm(stackPos), xmm(stackPos-1), operator_
     | vptestps xmm(stackPos), xmm(stackPos)
     if(condition){
         | jnz => labelNumber
     }
     else{
        | jz => labelNumber
     }
     stackPos--;
}

/**
 * @see assembly.hh
 */
void Assembly__AVX::calculateAddition(){
    | vaddsd xmm(stackPos-1), xmm(stackPos-1), xmm(stackPos)
    stackPos--;
}

/**
 * @see assembly.hh
 */
void Assembly__AVX::calculateSubtraction(){
    | vsubsd xmm(stackPos-1), xmm(stackPos-1), xmm(stackPos)
    stackPos--;
}

/**
 * @see assembly.hh
 */
void Assembly__AVX::calculateMultiplication(){
    | vmulsd xmm(stackPos-1), xmm(stackPos-1), xmm(stackPos)
    stackPos--;
}

/**
 * @see assembly.hh
 */
void Assembly__AVX::calculateDivision(){
    | vdivsd xmm(stackPos-1), xmm(stackPos-1), xmm(stackPos)
    stackPos--;
}

/**
 * @see assembly.hh
 */
void Assembly__AVX::callExternalFunction(externalFunction functionPtr, unsigned numberOfArguments){

    //Backup the stack. Function arguments will be replaced by a result
    //and therefor excluded from the backup.
    for(int i=0; i<stackPos-(numberOfArguments-1); i++){
       | sub rsp, 8
       | vmovq qword [rsp], xmm(i)
    }


    //Load parameters to register
    for(int i=stackPos-(numberOfArguments-1); i<=stackPos; i++){
       | vmovq xmm(i-(stackPos-(numberOfArguments-1))), xmm(i)
    }

    //Function parameters are not needed anymore
    //Set the stackPos accordingly
    stackPos = stackPos-(numberOfArguments-1);

    // Save frame pointer in non-volatile register
    | mov r12, rsp

    // Align frame pointer on 16 bit
    | and rsp, -16

    // Add Shadow space (32bit)
    // Not sure, if this is still needed.
    | sub rsp, 32

    // Move address of function to register
    | mov64 rax, (uintptr_t) functionPtr

    // Call function
    | call rax

    // Restore rsp
    | mov rsp, r12


    //Put function result on top of stack
    | vmovq xmm(stackPos), xmm0

    //Restore old stack
    for(int i=stackPos-1; i>=0; i--){
        | vmovq xmm(i), qword [rsp]
        | add rsp, 8
    }
}

/**
 * @see assembly.hh
 */
void Assembly__AVX::extractResult(){
    | vmovq xmm0, xmm(stackPos)
}

/**
 * @see assembly.hh
 */
void Assembly__AVX::epilogue(){
    | mov rsp, rbp
    | pop rbp
    | ret
}

/**
 * @see assembly.hh
 */
dasm_gen_func Assembly__AVX::linkAndEncode(){
  size_t sz;
  void* buf;

  // Retrieve the necessary amount of memory
  dasm_link(Dst, &sz);

  // Allocate executable memory
  buf = mmap(0, sz, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);

  // Copy machine executable code to allocated memory
  dasm_encode(Dst, buf);

  // Allocating executable memory is not sufficient. Change the access protection to executable
  mprotect(buf, sz, PROT_READ | PROT_EXEC);

  // Finally...return the function pointer :)
  return (dasm_gen_func) buf;
}

