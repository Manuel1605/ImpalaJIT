/**
 * Copyright 2017 Manuel Fasching <manuel.fasching@tum.de>
 * Distributed under the MIT License
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is furnished
 * to do so, subject to the following conditions:
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
 * INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
 * PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
 * FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

#include <assembly.hh>
#include <iostream>
#include <math.h>
#include <stdio.h>


|.arch x64

|.section code, imports

|.globals lbl_
|.actionlist impala_actions


|.macro call_extern, target
|  .imports
|  ->__imp__..target:
|  .dword  (uint32_t)target
|  .dword ((uint64_t)target >> 32)
|  .code
|  call qword [->__imp__..target]
|.endmacro


#include <sys/mman.h>

#if !defined(MAP_ANONYMOUS) && defined(MAP_ANON)
#define MAP_ANONYMOUS MAP_ANON
#endif

Assembly::~Assembly()
{
    dasm_free(&d);
}

void Assembly::initialize() {
    dasm_init(&d, DASM_MAXSECTION);

    void* labels[lbl__MAX];
    dasm_setupglobal(&d, labels, lbl__MAX);

    dasm_setup(&d, impala_actions);

    dasm_growpc(&d, 0);

    Dst = &d;
}

void Assembly::prologue(){

    | push rbp
    | mov rbp, rsp
    | mov rax, rbp
    | sub rax, 16
}

void Assembly::growPC(unsigned npc)
{
    dasm_growpc(&d, npc);
}

void Assembly::pushConstantToFPUStack(double *value){
    | fld qword [value]
}

void Assembly::storeLocalVariable() {
    | fstp qword [rax]
    | sub rax, 8
}

void Assembly::pushParameterToFPUStack(int index) {
    switch(index){
        case 0:
            {
                | movlpd qword [rbp-8], xmm0
                | fld qword [rbp-8]
                break;
            }
        case 1:
            {
                | movlpd qword [rbp-8], xmm1
                | fld qword [rbp-8]
                break;
            }
        case 2:
            {
                | movlpd qword [rbp-8], xmm2
                | fld qword [rbp-8]
                break;
            }
        case 3:
            {
                | movlpd qword [rbp-8], xmm3
                | fld qword [rbp-8]
                break;
            }
        case 4:
            {
                | movlpd qword [rbp-8], xmm4
                | fld qword [rbp-8]
                break;
            }
        case 5:
            {
                | movlpd qword [rbp-8], xmm5
                | fld qword [rbp-8]
                break;
            }
        case 6:
            {
                | movlpd qword [rbp-8], xmm6
                | fld qword [rbp-8]
                break;
            }
        case 7:
            {
                | movlpd qword [rbp-8], xmm7
                | fld qword [rbp-8]
                break;
            }
        default:
            {
                | fld qword [rbp+(8+(index-7)*8)]
                break;
            }
    }
}

void Assembly::replaceParameter(int index) {
    switch(index){
        case 0:
            {
                | fstp qword [rbp-8]
                | movlpd xmm0, qword [rbp-8]
                break;
            }
        case 1:
            {
                | fstp qword [rbp-8]
                | movlpd xmm1, qword [rbp-8]
                break;
            }
        case 2:
            {
                | fstp qword [rbp-8]
                | movlpd xmm2, qword [rbp-8]
                break;
            }
        case 3:
            {
                | fstp qword [rbp-8]
                | movlpd xmm3, qword [rbp-8]
                break;
            }
        case 4:
            {
                | fstp qword [rbp-8]
                | movlpd xmm4, qword [rbp-8]
                break;
            }
        case 5:
            {
                | fstp qword [rbp-8]
                | movlpd xmm5, qword [rbp-8]
                break;
            }
        case 6:
            {
                | fstp qword [rbp-8]
                | movlpd xmm6, qword [rbp-8]
                break;
            }
        case 7:
            {
                | fstp qword [rbp-8]
                | movlpd xmm7, qword [rbp-8]
                break;
            }
        default:
            {
                | fstp qword [rbp+(8+(index-7)*8)]
                break;
            }
    }
}

void Assembly::pushLocalVariableToFPUStack(int index) {
    | fld qword [rbp-(16+index*8)]
}

void Assembly::replaceLocalVariable(int index) {
    | fstp qword [rbp-(16+index*8)]
}

void Assembly::addDynamicLabel(unsigned labelNumber) {
    | =>labelNumber:
}

void Assembly::jumpForwardToDynamicLabel(unsigned labelNumber) {
    | jmp =>labelNumber
}


void Assembly::conditionalJumpForwardToDynamicLabel(unsigned labelNumber, bool condition, CompareOperatorType operator_){
    if(condition == false){
        switch(operator_){
            case EQ:
            {
                | jne  =>labelNumber
                break;
            }
            case NE:
            {
                | je  =>labelNumber
                break;
            }
            case GT:
            {
                | jbe  =>labelNumber
                break;
            }
            case LT:
            {
                | jae  =>labelNumber
                break;
            }
            case GTE:
            {
                | jb  =>labelNumber
                break;
            }
            case LTE:
            {
                | ja  =>labelNumber
                break;
            }
        }
    }
    else{
        switch(operator_){
            case EQ:
            {
                | je  =>labelNumber
                break;
            }
            case NE:
            {
                | jne  =>labelNumber
                break;
            }
            case GT:
            {
                | ja  =>labelNumber
                break;
            }
            case LT:
            {
                | jb  =>labelNumber
                break;
            }
            case GTE:
            {
                | jge  =>labelNumber
                break;
            }
            case LTE:
            {
                | jbe  =>labelNumber
                break;
            }
        }
     }
}

void Assembly::performNegation(){
    | fchs
}

void Assembly::calculateAddition(){
    | faddp st1
}

void Assembly::calculateSubtraction(){
    | fsubp st1
}

void Assembly::calculateMultiplication(){
    | fmulp st1
}

void Assembly::calculateDivision(){
    | fdivp st1
}

void Assembly::calculatePower(){
    | fld st1
    | ftst
    | fstsw ax
    | sahf
    | jz >1

    | ftst
    | fstsw ax
    | sahf
    | jz >2

    | fyl2x
    | fld st0
    | frndint
    | fsubr st1,st0
    | fxch st1
    | fchs
    | f2xm1
    | fld1
    | faddp st1,st0
    | fscale
    | fstp st1
    | jmp >3

    | 1:
    | fpop
    | fpop
    | fpop
    | fld1
    | jmp >3

    | 2:
    | fpop
    | fpop
    | fld1
    | fld1
    | fsub st1

    | 3:
}

void Assembly::calculateSQRT(){
    | fsqrt
}

void Assembly::performComparison(){
    | fcomip st1
    | fpop
}

void Assembly::extractResult(){
     | fstp qword [rbp-8]
     | movlpd xmm0, qword [rbp-8]
}


void Assembly::epilogue(){
    | pop rbp
    | ret
}

dasm_gen_func Assembly::linkAndEncode(){
  size_t sz;
  void* buf;
  dasm_link(Dst, &sz);
  buf = mmap(0, sz, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);
  dasm_encode(Dst, buf);
  mprotect(buf, sz, PROT_READ | PROT_EXEC);
  return (dasm_gen_func) buf;
}

